<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bunny Carrot Quest</title>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Comic Neue', cursive;
            background-color: #e6f3ff;
            touch-action: manipulation; /* Prevent mobile zoom */
        }
        h1 {
            font-size: 2.8em;
            color: #333;
            margin-bottom: 15px;
        }
        p {
            font-size: 1.3em;
            color: #666;
            margin: 5px 0;
        }
        canvas {
            background-color: #ccffcc;
            border: 3px solid #4a2f1d;
            border-radius: 5px;
            max-width: 100vw;
            max-height: 100vh;
        }
        #score, #timerDisplay {
            font-size: 1.3em;
            color: #006600;
            margin-top: 15px;
        }
        #winMessage {
            font-size: 1.6em;
            color: #ff4500;
            margin-top: 15px;
            font-weight: 700;
        }
        button {
            margin-top: 25px;
            padding: 12px 25px;
            font-size: 1.3em;
            font-family: 'Comic Neue', cursive;
            background-color: #ff9900;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #e68a00;
        }
        /* Mobile Controls */
        #controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
        .control-btn {
            width: 60px;
            height: 60px;
            margin: 10px;
            background-color: #ff9900;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
        }
        @media (max-width: 768px) {
            #controls {
                display: flex;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <h1>Bunny Carrot Quest</h1>
    <p>Move with arrow keys or touch controls to collect all carrots before time runs out!</p>
    <canvas id="gameCanvas"></canvas>
    <p id="score">Level: 1 - Carrots: 0 / 4</p>
    <p id="timerDisplay">Time Left: 60s</p>
    <p id="winMessage"></p>
    <button id="resetButton">Play Again</button>

    <!-- Mobile Controls -->
    <div id="controls">
        <button class="control-btn" id="leftBtn">←</button>
        <button class="control-btn" id="upBtn">↑</button>
        <button class="control-btn" id="downBtn">↓</button>
        <button class="control-btn" id="rightBtn">→</button>
    </div>

    <!-- Carrot Image (hidden) -->
    <img id="carrotImage" src="carrot.png" style="display:none;" alt="Carrot">

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const timerDisplay = document.getElementById('timerDisplay');
        const winMessage = document.getElementById('winMessage');
        const resetButton = document.getElementById('resetButton');
        const carrotImage = document.getElementById('carrotImage');

        const cellSize = 20;
        let maze, bunny, carrots, carrotCount, mazeSize, totalCarrots, timeLeft, timerInterval;
        let currentLevel = 0;

        // Generate 50 levels
        const levels = Array.from({ length: 50 }, (_, i) => {
            const size = 8 + Math.floor(i / 10) * 2; // 8x8 to 18x18
            const carrots = 4 + i; // 4 to 53 carrots
            const timeLimit = Math.max(30, 60 - i * 2); // 60s to 30s
            return {
                maze: generateMaze(size),
                size: size,
                totalCarrots: carrots,
                timeLimit: timeLimit,
                startPos: { x: 1, y: 1 }
            };
        });

        // Maze generation using recursive backtracking
        function generateMaze(size) {
            const maze = Array.from({ length: size }, () => Array(size).fill(1));
            function carve(x, y) {
                maze[y][x] = 0;
                const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
                directions.sort(() => Math.random() - 0.5);
                for (const [dx, dy] of directions) {
                    const nx = x + dx * 2, ny = y + dy * 2;
                    if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && maze[ny][nx] === 1) {
                        maze[y + dy][x + dx] = 0;
                        carve(nx, ny);
                    }
                }
            }
            carve(1, 1);
            return maze;
        }

        // Load a level
        function loadLevel(levelIndex) {
            const level = levels[levelIndex];
            maze = level.maze;
            mazeSize = level.size;
            totalCarrots = level.totalCarrots;
            bunny = { ...level.startPos };
            carrots = [];
            carrotCount = 0;
            timeLeft = level.timeLimit;
            winMessage.textContent = '';
            timerDisplay.textContent = `Time Left: ${timeLeft}s`;

            // Ensure bunny starts on an open path
            while (maze[bunny.y][bunny.x] === 1) {
                bunny.x = (bunny.x + 1) % mazeSize;
                if (bunny.x === 0) bunny.y = (bunny.y + 1) % mazeSize;
            }

            // Set canvas size
            canvas.width = mazeSize * cellSize;
            canvas.height = mazeSize * cellSize;

            spawnCarrots();
            render();
            startTimer();
        }

        // Spawn carrots randomly
        function spawnCarrots() {
            while (carrots.length < totalCarrots) {
                let x = Math.floor(Math.random() * mazeSize);
                let y = Math.floor(Math.random() * mazeSize);
                if (maze[y][x] === 0 && (x !== bunny.x || y !== bunny.y)) {
                    carrots.push({ x, y });
                }
            }
        }

        // Render the game
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            renderMaze();
            renderCarrots();
            renderBunny();
            scoreDisplay.textContent = `Level: ${currentLevel + 1} - Carrots: ${carrotCount} / ${totalCarrots}`;
        }

        function renderMaze() {
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#4a2f1d'; // Walls
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function renderBunny() {
            const x = bunny.x * cellSize + cellSize / 2;
            const y = bunny.y * cellSize + cellSize / 2;

            // Bunny body
            ctx.fillStyle = '#808080'; // Gray
            ctx.beginPath();
            ctx.arc(x, y, 9, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.ellipse(x - 5, y - 10, 3, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 5, y - 10, 3, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x - 4, y - 3, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 4, y - 3, 2, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x - 4, y - 3, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 4, y - 3, 1, 0, Math.PI * 2);
            ctx.fill();
        }

        function renderCarrots() {
            if (carrotImage.complete) {
                carrots.forEach(carrot => {
                    const x = carrot.x * cellSize;
                    const y = carrot.y * cellSize;
                    ctx.drawImage(carrotImage, x, y, cellSize, cellSize);
                });
            } else {
                // Fallback if image not loaded
                carrots.forEach(carrot => {
                    const x = carrot.x * cellSize + cellSize / 2;
                    const y = carrot.y * cellSize + cellSize / 2;
                    ctx.fillStyle = '#ff9900';
                    ctx.beginPath();
                    ctx.moveTo(x, y - 6);
                    ctx.lineTo(x - 6, y + 4);
                    ctx.lineTo(x + 6, y + 4);
                    ctx.closePath();
                    ctx.fill();
                });
            }
        }

        // Bunny movement
        function moveBunny(dx, dy) {
            const newX = bunny.x + dx;
            const newY = bunny.y + dy;
            if (newX >= 0 && newX < mazeSize && newY >= 0 && newY < mazeSize && maze[newY][newX] === 0) {
                bunny.x = newX;
                bunny.y = newY;
                collectCarrot();
                render();
                checkVictory();
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            e.preventDefault();
            switch (e.key) {
                case 'ArrowUp': moveBunny(0, -1); break;
                case 'ArrowDown': moveBunny(0, 1); break;
                case 'ArrowLeft': moveBunny(-1, 0); break;
                case 'ArrowRight': moveBunny(1, 0); break;
            }
        });

        // Mobile controls
        document.getElementById('upBtn').addEventListener('click', () => moveBunny(0, -1));
        document.getElementById('downBtn').addEventListener('click', () => moveBunny(0, 1));
        document.getElementById('leftBtn').addEventListener('click', () => moveBunny(-1, 0));
        document.getElementById('rightBtn').addEventListener('click', () => moveBunny(1, 0));

        // Carrot collection
        function collectCarrot() {
            carrots = carrots.filter(carrot => {
                if (carrot.x === bunny.x && carrot.y === bunny.y) {
                    carrotCount++;
                    return false; // Remove the carrot
                }
                return true;
            });
        }

        // Check for victory
        function checkVictory() {
            if (carrotCount === totalCarrots) {
                clearInterval(timerInterval);
                if (currentLevel + 1 < levels.length) {
                    currentLevel++;
                    loadLevel(currentLevel);
                } else {
                    winMessage.textContent = 'Congratulations! You completed all 50 levels!';
                }
            }
        }

        // Timer
        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = `Time Left: ${timeLeft}s`;
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    winMessage.textContent = 'Time\'s up! Try again.';
                    setTimeout(() => loadLevel(currentLevel), 2000);
                }
            }, 1000);
        }

        // Start and reset game
        function startGame() {
            currentLevel = 0;
            loadLevel(currentLevel);
        }

        resetButton.addEventListener('click', startGame);

        // Start the game initially
        startGame();
    </script>
</body>
</html>
